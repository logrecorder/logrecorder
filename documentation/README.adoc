= LogRecorder

== Artifacts

=== API

The `logrecorder-api` artifacts provides the basic components and interfaces for implementing a LogRecord.
On its own this artifact does not provide any functionality.
It must be coupled with an actual implementation.
Programmatic usage is provided with the chosen implementation.
Testframework support requires an additional optional artifact

.Gradle
[source,groovy]
----
testImplementation("io.github.logrecorder:logrecorder-api:${logrecorder.version}")
----

.Maven
[source,xml]
----
<dependency>
    <groupId>io.github.logrecorder</groupId>
    <artifactId>logrecorder-api</artifactId>
    <version>${logrecorder.version}</version>
    <scope>test</scope>
</dependency>
----

=== Framework Support: Junit5

.Gradle
[source,groovy]
----
testImplementation("io.github.logrecorder:logrecorder-common-junit5:${logrecorder.version}")
----

.Maven
[source,xml]
----
<dependency>
    <groupId>io.github.logrecorder</groupId>
    <artifactId>logrecorder-common-junit5</artifactId>
    <version>${logrecorder.version}</version>
    <scope>test</scope>
</dependency>
----

=== Framework Support: Kotest

.Gradle
[source,groovy]
----
testImplementation("io.github.logrecorder:logrecorder-common-kotest:${logrecorder.version}")
----

.Maven
[source,xml]
----
<dependency>
    <groupId>io.github.logrecorder</groupId>
    <artifactId>logrecorder-common-kotest</artifactId>
    <version>${logrecorder.version}</version>
    <scope>test</scope>
</dependency>
----

=== Implementation: Logback

The `logrecorder-logback` provides everything you need to start recording any link:https://logback.qos.ch[Logback]-based logging activity.

.Gradle
[source,groovy]
----
testImplementation("io.github.logrecorder:logrecorder-logback:${logrecorder.version}")
----

.Maven
[source,xml]
----
<dependency>
    <groupId>io.github.logrecorder</groupId>
    <artifactId>logrecorder-logback</artifactId>
    <version>${logrecorder.version}</version>
    <scope>test</scope>
</dependency>
----

=== Implementation: Log4j

The `logrecorder-log4j` provides everything you need to start recording any link:https://logging.apache.org/log4j/2.x/[Log4j]-based logging activity.

.Gradle
[source,groovy]
----
testImplementation("io.github.logrecorder:logrecorder-log4j:${logrecorder.version}")
----

.Maven
[source,xml]
----
<dependency>
    <groupId>io.github.logrecorder</groupId>
    <artifactId>logrecorder-log4j</artifactId>
    <version>${logrecorder.version}</version>
    <scope>test</scope>
</dependency>
----

=== Implementation: Java Util Logging (JUL)

The `logrecorder-jul` provides everything you need to start recording any link:https://cr.openjdk.java.net/~iris/se/11/latestSpec/api/java.logging/java/util/logging/package-summary.html[JUL]-based logging activity.

.Gradle
[source,groovy]
----
testImplementation("io.github.logrecorder:logrecorder-jul:${logrecorder.version}")
----

.Maven
[source,xml]
----
<dependency>
    <groupId>io.github.logrecorder</groupId>
    <artifactId>logrecorder-jul</artifactId>
    <version>${logrecorder.version}</version>
    <scope>test</scope>
</dependency>
----

=== Assertions

The `logrecorder-assertions` artifacts provides a Kotlin based DSL for asserting the content of log recordings.

.Gradle
[source,groovy]
----
testImplementation("io.github.logrecorder:logrecorder-assertions:${logrecorder.version}")
----

.Maven
[source,xml]
----
<dependency>
    <groupId>io.github.logrecorder</groupId>
    <artifactId>logrecorder-assertions</artifactId>
    <version>${logrecorder.version}</version>
    <scope>test</scope>
</dependency>
----

== Usage Examples

=== Kotlin

.Example how to use LogRecorder with Junit5 in Kotlin
[source,kotlin]
----
import io.github.logrecorder.api.LogEntry
import io.github.logrecorder.api.LogLevel
import io.github.logrecorder.api.LogRecord
import io.github.logrecorder.api.LogRecord.Companion.logger
import io.github.logrecorder.logback.junit5.RecordLoggers
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import java.util.function.Consumer

internal class LogRecorderExtensionTest {

    private val testServiceA = TestServiceA()

    @Test
    @RecordLoggers(TestServiceA::class) // define from which class you want to test log messages
    fun `extension is registered and log messages are recorded`(log: LogRecord) {
        assertThat(log.entries).isEmpty()

        testServiceA.logSomething()

        // check only messages
        assertThat(log.messages).containsExactly(
            "trace message a",
            "debug message a",
            "info message a",
            "warn message a",
            "error message a"
        )

        //check only markers
        assertThat(log.markers).containsExactly(
            "trace marker a",
            null,
            null,
            null,
            null
        )

        //check for throwable
        testServiceA.logError()
        assertThat(log.entries).anySatisfy(Consumer {
            assertThat(it.throwable)
                .isInstanceOf(RuntimeException::class.java)
                .hasMessage("error")
        })

        // check message, log level and markers
        // the next example will show how this can be done a lot easier using the assertion DSL
        assertThat(log.entries).containsExactly(
            LogEntry(logger(TestServiceA::class), LogLevel.TRACE, "trace message a", "trace marker a"),
            LogEntry(logger(TestServiceA::class), LogLevel.DEBUG, "debug message a", null),
            // null is default value for markers
            LogEntry(logger(TestServiceA::class), LogLevel.INFO, "info message a"),
            LogEntry(logger(TestServiceA::class), LogLevel.WARN, "warn message a"),
            LogEntry(logger(TestServiceA::class), LogLevel.ERROR, "error message a")
        )
    }
}

----

.Example for LogRecorder with Kotest in Kotlin
[source,kotlin]
----
import io.github.logrecorder.api.LogEntry
import io.github.logrecorder.api.LogLevel
import io.github.logrecorder.api.LogRecord.Companion.logger
import io.github.logrecorder.common.kotest.logRecord
import io.github.logrecorder.logback.kotest.recordLogs
import io.github.logrecorder.logback.util.TestServiceA
import io.kotest.core.spec.style.FunSpec
import org.assertj.core.api.Assertions.assertThat

internal class LogRecorderExtensionTest : FunSpec({

    val testServiceA = TestServiceA()

    test("extension is registered and log messages are recorded").config(
        extensions = listOf(recordLogs(TestServiceA::class))
    ) {
        assertThat(logRecord.entries).isEmpty()

        assertThat(logRecord.entries).containsExactly(
            LogEntry(logger(TestServiceA::class), LogLevel.TRACE, "trace message a", "trace marker a"),
            LogEntry(logger(TestServiceA::class), LogLevel.DEBUG, "debug message a", null),
            LogEntry(logger(TestServiceA::class), LogLevel.INFO, "info message a"),
            LogEntry(logger(TestServiceA::class), LogLevel.WARN, "warn message a"),
            LogEntry(logger(TestServiceA::class), LogLevel.ERROR, "error message a")
        )
    }
})
----

.Example for LogRecorder purely programmatic in Kotlin (using Junit5)
[source,kotlin]
----
import io.github.logrecorder.api.LogEntry
import io.github.logrecorder.api.LogLevel
import io.github.logrecorder.api.LogRecord.Companion.logger
import io.github.logrecorder.logback.programmatic.recordLoggers
import io.github.logrecorder.logback.util.TestServiceA
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

internal class LogRecorderProgrammatic {

    private val testServiceA = TestServiceA()

    @Test
    internal fun `log messages are recorded in lamda an returned`() {
        val logRecord = recordLoggers(TestServiceA::class) { log ->
            assertThat(log.entries).isEmpty()

            testServiceA.logSomething()

            assertThat(log.entries).contains(
                LogEntry(logger(TestServiceA::class), LogLevel.TRACE, "trace message a", "marker a"),
                LogEntry(logger(TestServiceA::class), LogLevel.DEBUG, "debug message a", null),
            )
            log
        }
        assertThat(logRecord.entries).contains(
            LogEntry(logger(TestServiceA::class), LogLevel.INFO, "info message a"),
            LogEntry(logger(TestServiceA::class), LogLevel.WARN, "warn message a"),
            LogEntry(logger(TestServiceA::class), LogLevel.ERROR, "error message a")
        )
    }
}
----

.Example for LogRecorder assertions in Kotlin
[source,kotlin]
----
import io.github.logrecorder.api.LogRecord
import io.github.logrecorder.assertion.LogRecordAssertion.assertThat
import io.github.logrecorder.logback.junit5.RecordLoggers

...

@Test
@RecordLoggers(MyService::class)
fun `failures are logged correctly`(log: LogRecord) {
    doSomethingFailing()

    assertThat(log) {
        containsExactly {
            any("trying to do something")
            debug("debug message")
            info("info message")
            error(startsWith("something failed with exception:"))
        }
    }
}
----

=== Java

.Example for LogRecorder in native Java
[source,java]
----
package io.github.logrecorder.example;

import io.github.logrecorder.api.LogEntry;
import io.github.logrecorder.api.LogLevel;
import io.github.logrecorder.api.LogRecord;
import io.github.logrecorder.api.LogRecord.Companion.logger;
import io.github.logrecorder.assertion.AssertionBlock;
import io.github.logrecorder.assertion.ContainsExactly;
import io.github.logrecorder.logback.junit5.RecordLoggers;
import org.assertj.core.api.Assertions.assertThat;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

public class LogRecorderExtensionTest {

  private final TestServiceA serviceA = new TestServiceA();

  @Test
  @RecordLoggers({TestServiceA.class}) // define from which class you want to test log messages
  public void testLoggingServiceA(LogRecord log) {
    assertThat(log.getEntries()).isEmpty();

    // TestServiceA and TestServiceB produces logs
    serviceA.logSomething();

    // check only messages
    assertThat(log.getMessages()).containsExactly(
        "trace message a",
        "debug message a",
        "info message a",
        "warn message a",
        "error message a"
    );

    //check only markers
    assertThat(log.markers).containsExactly(
        "trace marker a",
        null,
        null,
        null,
        null
    );

    // check message, log level and markers
    assertThat(log.getEntries()).containsExactly(
        new LogEntry(logger(TestServiceA.class), LogLevel.TRACE, "trace message a", "trace marker a"),
        new LogEntry(logger(TestServiceA.class), LogLevel.DEBUG, "debug message a", null),
        // null is default value for markers
        new LogEntry(logger(TestServiceA.class), LogLevel.INFO, "info message a"),
        new LogEntry(logger(TestServiceA.class), LogLevel.WARN, "warn message a"),
        new LogEntry(logger(TestServiceA.class), LogLevel.ERROR, "error message a")
    );
  }
}
----
